#include <iostream>

#include <SDL2/SDL_loadso.h>
#include <SDL2/SDL_keycode.h>

#include "XSCommon/XSCommon.h"
#include "XSCommon/XSConsole.h"
#include "XSCommon/XSString.h"
#include "XSCommon/XSCvar.h"
#include "XSClient/XSClient.h"
#include "XSClient/XSInputField.h"
#include "XSRenderer/XSFont.h"
#include "XSRenderer/XSView.h"

namespace XS {

	namespace Client {

//#define BUILD_CLIENT_MODULE

		static uint64_t frameNum = 0u;

	#ifdef BUILD_CLIENT_MODULE
		typedef const char * (*initFunc_t)(uint32_t);
		#define MODULE_NAME "client" ARCH_STRING DLL_EXT
		static const uint32_t MODULE_VERSION = 1u;
		static void *moduleHandle = nullptr;
	#endif // BUILD_CLIENT_MODULE

		static Renderer::View *hudView = nullptr;

		//
		// Console
		//

		static bool consoleVisible = false;
		int scrollAmount = 0;
		const unsigned int lineCount = 24u;
		static Cvar *con_fontSize = nullptr;
		static InputField *consoleInput = nullptr;
		static Renderer::View *consoleView = nullptr;

		static void ConsoleInputCallback( const char *text ) {
			Command::Append( text );
		}

		void Cmd_ToggleConsole( const commandContext_t * context ) {
			if ( consoleVisible ) {
				consoleInput->Clear();
			}
			consoleVisible = !consoleVisible;
		}

		bool ConsoleKeyEvent( SDL_Keycode key, bool down ) {
			if ( !consoleVisible ) {
				return false;
			}

			if ( down ) {
				//TODO: scroll input cursor with SDL_SCANCODE_LEFT, SDL_SCANCODE_RIGHT
				//TODO: scroll up/down through history with SDL_SCANCODE_UP, SDL_SCANCODE_DOWN
				if ( key == SDLK_BACKQUOTE ) {
					// hardcoded console exit
					Cmd_ToggleConsole( NULL );
					return true;
				}
				else if ( consoleInput->KeyEvent( key, down ) ) {
					return true;
				}
			}

			return false;
		}

		void Init( void ) {
#ifdef BUILD_CLIENT_MODULE
			// initialise the client library
			char modulePath[XS_MAX_FILENAME];
			File::GetFullPath( MODULE_NAME, modulePath, sizeof( modulePath ) );
			moduleHandle = SDL_LoadObject( modulePath );
			if ( !moduleHandle ) {
				throw( XSError( "Could not find client module (" MODULE_NAME ")" ) );
				return;
			}

			if ( initFunc_t init = (initFunc_t)SDL_LoadFunction( moduleHandle, "LoadModule" ) ) {
				const char *msg = init( MODULE_VERSION );
				if ( msg ) {
					throw( XSError( msg ) );
				}
			}
			else {
				throw( XSError( "Could not load client module (" MODULE_NAME ")" ) );
			}
#endif // BUILD_CLIENT_MODULE

			const uint32_t width = Cvar::Get( "vid_width" )->GetInt();
			const uint32_t height= Cvar::Get( "vid_height" )->GetInt();
			hudView = new Renderer::View( width, height, true );

			con_fontSize = Cvar::Create( "con_fontSize", "12", "Size of the console font", CVAR_ARCHIVE );
			consoleInput = new InputField( ConsoleInputCallback );
			consoleView = new Renderer::View( width, height, true );
		}

		void Shutdown( void ) {
		#ifdef BUILD_CLIENT_MODULE
			if ( moduleHandle ) {
				SDL_UnloadObject( moduleHandle );
			}
		#endif // BUILD_CLIENT_MODULE
		}

		void NetworkPump( void ) {
			// create game context from any server updates we receieved since the last frame
		}

		void RunFrame( double dt ) {
			static double stepTime = 0.0;
			frameNum++;

			// previousState = currentState;
			// integrate( currentState, stepTime, dt );
			stepTime += dt;

			// process server updates
			// simulate local entities
			//	predict entities whose state is not managed by the server, created by either the client or server
			//	e.g. client may create its own projectiles until the server overrides it
			// movement prediction (movement commands have been generated by input poll)
		}

		static void DrawHUD( double frametime ) {
			hudView->Bind();

			static const vector2 pos = vector2( 0.0f, 0.0f );
			static Renderer::Font *font = nullptr;
			if ( !font ) {
				font = Renderer::Font::Register( "menu", 16 );
			}

			static double samples[16];
			static unsigned int index = 0;
			samples[index++] = frametime;
			if ( index >= 16 ) {
				index = 0u;
			}
			double avg = 0.0;
			for ( int i = 0; i < 16; i++ ) {
				avg += samples[i];
			}
			avg /= 16.0;
			font->Draw( pos, String::Format( "FPS:%.5f\nTesting second line.", 1000.0 / avg ) );
		}

		static void DrawConsole( void ) {
			if ( !consoleVisible ) {
				return;
			}

			consoleView->Bind();

			static Renderer::Font *font = nullptr;
			if ( !font ) {
				font = Renderer::Font::Register( "console", con_fontSize->GetInt() );
			}

			std::vector<std::string> lines = console.buffer->GetLines( lineCount );
			vector2 pos( 0.0f, 0.0f );
			for ( const auto &it : lines ) {
				font->Draw( pos, it );
				pos.y += font->lineHeight;
			}
		}

		void DrawFrame( double frametime ) {
			// draw game view

			// draw HUD
			DrawHUD( frametime );

			// draw console
			DrawConsole();
		}

	} // namespace Client

} // namespace XS
